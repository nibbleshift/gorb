// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package client

import (
	"fmt"
	"io"
	"strconv"
)

type Bench struct {
	ID          string         `json:"id"`
	Os          string         `json:"os"`
	Arch        string         `json:"arch"`
	CPU         string         `json:"cpu"`
	Package     string         `json:"package"`
	Pass        bool           `json:"pass"`
	BenchResult []*BenchResult `json:"benchResult"`
}

func (Bench) IsNode() {}

// A connection to a list of items.
type BenchConnection struct {
	// A list of edges.
	Edges []*BenchEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type BenchEdge struct {
	// The item at the end of the edge.
	Node *Bench `json:"node"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type BenchResult struct {
	ID                string  `json:"id"`
	Name              string  `json:"name"`
	N                 int64   `json:"n"`
	NsPerOp           float64 `json:"nsPerOp"`
	AllocedBytesPerOp int64   `json:"allocedBytesPerOp"`
	AllocsPerOp       int64   `json:"allocsPerOp"`
	MbPerS            float64 `json:"mbPerS"`
	Measured          int64   `json:"measured"`
	Ord               int64   `json:"ord"`
}

func (BenchResult) IsNode() {}

// A connection to a list of items.
type BenchResultConnection struct {
	// A list of edges.
	Edges []*BenchResultEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type BenchResultEdge struct {
	// The item at the end of the edge.
	Node *BenchResult `json:"node"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// BenchResultWhereInput is used for filtering BenchResult objects.
// Input was generated by ent.
type BenchResultWhereInput struct {
	Not *BenchResultWhereInput   `json:"not,omitempty"`
	And []*BenchResultWhereInput `json:"and,omitempty"`
	Or  []*BenchResultWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// n field predicates
	N      *int64  `json:"n,omitempty"`
	NNeq   *int64  `json:"nNEQ,omitempty"`
	NIn    []int64 `json:"nIn,omitempty"`
	NNotIn []int64 `json:"nNotIn,omitempty"`
	NGt    *int64  `json:"nGT,omitempty"`
	NGte   *int64  `json:"nGTE,omitempty"`
	NLt    *int64  `json:"nLT,omitempty"`
	NLte   *int64  `json:"nLTE,omitempty"`
	// ns_per_op field predicates
	NsPerOp      *float64  `json:"nsPerOp,omitempty"`
	NsPerOpNeq   *float64  `json:"nsPerOpNEQ,omitempty"`
	NsPerOpIn    []float64 `json:"nsPerOpIn,omitempty"`
	NsPerOpNotIn []float64 `json:"nsPerOpNotIn,omitempty"`
	NsPerOpGt    *float64  `json:"nsPerOpGT,omitempty"`
	NsPerOpGte   *float64  `json:"nsPerOpGTE,omitempty"`
	NsPerOpLt    *float64  `json:"nsPerOpLT,omitempty"`
	NsPerOpLte   *float64  `json:"nsPerOpLTE,omitempty"`
	// alloced_bytes_per_op field predicates
	AllocedBytesPerOp      *int64  `json:"allocedBytesPerOp,omitempty"`
	AllocedBytesPerOpNeq   *int64  `json:"allocedBytesPerOpNEQ,omitempty"`
	AllocedBytesPerOpIn    []int64 `json:"allocedBytesPerOpIn,omitempty"`
	AllocedBytesPerOpNotIn []int64 `json:"allocedBytesPerOpNotIn,omitempty"`
	AllocedBytesPerOpGt    *int64  `json:"allocedBytesPerOpGT,omitempty"`
	AllocedBytesPerOpGte   *int64  `json:"allocedBytesPerOpGTE,omitempty"`
	AllocedBytesPerOpLt    *int64  `json:"allocedBytesPerOpLT,omitempty"`
	AllocedBytesPerOpLte   *int64  `json:"allocedBytesPerOpLTE,omitempty"`
	// allocs_per_op field predicates
	AllocsPerOp      *int64  `json:"allocsPerOp,omitempty"`
	AllocsPerOpNeq   *int64  `json:"allocsPerOpNEQ,omitempty"`
	AllocsPerOpIn    []int64 `json:"allocsPerOpIn,omitempty"`
	AllocsPerOpNotIn []int64 `json:"allocsPerOpNotIn,omitempty"`
	AllocsPerOpGt    *int64  `json:"allocsPerOpGT,omitempty"`
	AllocsPerOpGte   *int64  `json:"allocsPerOpGTE,omitempty"`
	AllocsPerOpLt    *int64  `json:"allocsPerOpLT,omitempty"`
	AllocsPerOpLte   *int64  `json:"allocsPerOpLTE,omitempty"`
	// mb_per_s field predicates
	MbPerS      *float64  `json:"mbPerS,omitempty"`
	MbPerSneq   *float64  `json:"mbPerSNEQ,omitempty"`
	MbPerSIn    []float64 `json:"mbPerSIn,omitempty"`
	MbPerSNotIn []float64 `json:"mbPerSNotIn,omitempty"`
	MbPerSgt    *float64  `json:"mbPerSGT,omitempty"`
	MbPerSgte   *float64  `json:"mbPerSGTE,omitempty"`
	MbPerSlt    *float64  `json:"mbPerSLT,omitempty"`
	MbPerSlte   *float64  `json:"mbPerSLTE,omitempty"`
	// measured field predicates
	Measured      *int64  `json:"measured,omitempty"`
	MeasuredNeq   *int64  `json:"measuredNEQ,omitempty"`
	MeasuredIn    []int64 `json:"measuredIn,omitempty"`
	MeasuredNotIn []int64 `json:"measuredNotIn,omitempty"`
	MeasuredGt    *int64  `json:"measuredGT,omitempty"`
	MeasuredGte   *int64  `json:"measuredGTE,omitempty"`
	MeasuredLt    *int64  `json:"measuredLT,omitempty"`
	MeasuredLte   *int64  `json:"measuredLTE,omitempty"`
	// ord field predicates
	Ord      *int64  `json:"ord,omitempty"`
	OrdNeq   *int64  `json:"ordNEQ,omitempty"`
	OrdIn    []int64 `json:"ordIn,omitempty"`
	OrdNotIn []int64 `json:"ordNotIn,omitempty"`
	OrdGt    *int64  `json:"ordGT,omitempty"`
	OrdGte   *int64  `json:"ordGTE,omitempty"`
	OrdLt    *int64  `json:"ordLT,omitempty"`
	OrdLte   *int64  `json:"ordLTE,omitempty"`
}

// BenchWhereInput is used for filtering Bench objects.
// Input was generated by ent.
type BenchWhereInput struct {
	Not *BenchWhereInput   `json:"not,omitempty"`
	And []*BenchWhereInput `json:"and,omitempty"`
	Or  []*BenchWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// os field predicates
	Os             *string  `json:"os,omitempty"`
	OsNeq          *string  `json:"osNEQ,omitempty"`
	OsIn           []string `json:"osIn,omitempty"`
	OsNotIn        []string `json:"osNotIn,omitempty"`
	OsGt           *string  `json:"osGT,omitempty"`
	OsGte          *string  `json:"osGTE,omitempty"`
	OsLt           *string  `json:"osLT,omitempty"`
	OsLte          *string  `json:"osLTE,omitempty"`
	OsContains     *string  `json:"osContains,omitempty"`
	OsHasPrefix    *string  `json:"osHasPrefix,omitempty"`
	OsHasSuffix    *string  `json:"osHasSuffix,omitempty"`
	OsEqualFold    *string  `json:"osEqualFold,omitempty"`
	OsContainsFold *string  `json:"osContainsFold,omitempty"`
	// arch field predicates
	Arch             *string  `json:"arch,omitempty"`
	ArchNeq          *string  `json:"archNEQ,omitempty"`
	ArchIn           []string `json:"archIn,omitempty"`
	ArchNotIn        []string `json:"archNotIn,omitempty"`
	ArchGt           *string  `json:"archGT,omitempty"`
	ArchGte          *string  `json:"archGTE,omitempty"`
	ArchLt           *string  `json:"archLT,omitempty"`
	ArchLte          *string  `json:"archLTE,omitempty"`
	ArchContains     *string  `json:"archContains,omitempty"`
	ArchHasPrefix    *string  `json:"archHasPrefix,omitempty"`
	ArchHasSuffix    *string  `json:"archHasSuffix,omitempty"`
	ArchEqualFold    *string  `json:"archEqualFold,omitempty"`
	ArchContainsFold *string  `json:"archContainsFold,omitempty"`
	// cpu field predicates
	CPU             *string  `json:"cpu,omitempty"`
	CPUNeq          *string  `json:"cpuNEQ,omitempty"`
	CPUIn           []string `json:"cpuIn,omitempty"`
	CPUNotIn        []string `json:"cpuNotIn,omitempty"`
	CPUGt           *string  `json:"cpuGT,omitempty"`
	CPUGte          *string  `json:"cpuGTE,omitempty"`
	CPULt           *string  `json:"cpuLT,omitempty"`
	CPULte          *string  `json:"cpuLTE,omitempty"`
	CPUContains     *string  `json:"cpuContains,omitempty"`
	CPUHasPrefix    *string  `json:"cpuHasPrefix,omitempty"`
	CPUHasSuffix    *string  `json:"cpuHasSuffix,omitempty"`
	CPUEqualFold    *string  `json:"cpuEqualFold,omitempty"`
	CPUContainsFold *string  `json:"cpuContainsFold,omitempty"`
	// package field predicates
	Package             *string  `json:"package,omitempty"`
	PackageNeq          *string  `json:"packageNEQ,omitempty"`
	PackageIn           []string `json:"packageIn,omitempty"`
	PackageNotIn        []string `json:"packageNotIn,omitempty"`
	PackageGt           *string  `json:"packageGT,omitempty"`
	PackageGte          *string  `json:"packageGTE,omitempty"`
	PackageLt           *string  `json:"packageLT,omitempty"`
	PackageLte          *string  `json:"packageLTE,omitempty"`
	PackageContains     *string  `json:"packageContains,omitempty"`
	PackageHasPrefix    *string  `json:"packageHasPrefix,omitempty"`
	PackageHasSuffix    *string  `json:"packageHasSuffix,omitempty"`
	PackageEqualFold    *string  `json:"packageEqualFold,omitempty"`
	PackageContainsFold *string  `json:"packageContainsFold,omitempty"`
	// pass field predicates
	Pass    *bool `json:"pass,omitempty"`
	PassNeq *bool `json:"passNEQ,omitempty"`
	// bench_result edge predicates
	HasBenchResult     *bool                    `json:"hasBenchResult,omitempty"`
	HasBenchResultWith []*BenchResultWhereInput `json:"hasBenchResultWith,omitempty"`
}

// CreateBenchInput is used for create Bench object.
// Input was generated by ent.
type CreateBenchInput struct {
	Os             string   `json:"os"`
	Arch           string   `json:"arch"`
	CPU            string   `json:"cpu"`
	Package        string   `json:"package"`
	Pass           bool     `json:"pass"`
	BenchResultIDs []string `json:"benchResultIDs,omitempty"`
}

// CreateBenchResultInput is used for create BenchResult object.
// Input was generated by ent.
type CreateBenchResultInput struct {
	Name              string  `json:"name"`
	N                 int64   `json:"n"`
	NsPerOp           float64 `json:"nsPerOp"`
	AllocedBytesPerOp int64   `json:"allocedBytesPerOp"`
	AllocsPerOp       int64   `json:"allocsPerOp"`
	MbPerS            float64 `json:"mbPerS"`
	Measured          int64   `json:"measured"`
	Ord               int64   `json:"ord"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
